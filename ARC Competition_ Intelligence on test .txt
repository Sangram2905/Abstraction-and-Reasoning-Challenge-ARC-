{"cells":[{"metadata":{},"cell_type":"markdown","source":"# **Introduction**\n\n**Abstraction and Reasoning Challenge** :  As a beginner to look up this Challenge and comparing to our High school ABSTRACT REASONING TESTS Questions.\n\nIn this note book I like to solve this problem and it will show how we can use data visualization & Machine learning in python\n\n\n"},{"metadata":{},"cell_type":"markdown","source":"# **Contents:**\n\n**Preparing the ground**\n* About the Data #Code to exract some formats\n\n* Import libraries and define hyperparameters\n* Load the ARC data\n\n**Basic exploration**\n* Look at few train/test input/output pairs\n* Number frequency\n* Matrix mean values\n* Matrix heights\n* Matrix widths\n* Height vs. Width\n\n**Data processing**\n\n1. Modeling (Under process)\n1. Training and postprocessing (Under process)\n1. Loss (MAE) (Under process)\n1. Backpropagation and optimization (Under process)\n\n**Submission**\n\n**Ending note**\n"},{"metadata":{},"cell_type":"markdown","source":"# Preparing the ground"},{"metadata":{},"cell_type":"markdown","source":"**About the Data**"},{"metadata":{},"cell_type":"markdown","source":"#The task is consist of JSON file where each JSON file comes with following pairs:\n\nTask dictionary -> Test & Train list -> Train & Train Dictionary ->Input & output list-> Color data list \n1.\tWe can divide the data in following to simplify and Solvable formats\n2.\tMaximum grid is divided in  1X1 to 30X30 Rows X Columns \n3.\tGrid also can divide in 3 parts\n\n    a.\tSmall input big output\n    \n    b.\tBig Input Small output\n    \n    c.\tEqual input equal output\n    \n    d.\tSimple Input to (Simple, Medium or Hard) Output\n    \n    e.\tMedium Input to (Simple, Medium or Hard) Output\n   \n    f.\tHard Input to (Simple, Medium or Hard) Output\n   \n4.\tAbove Complex patterns calculated by grid size.\n5.\tColumns & rows can be sub divided as:\n    a.\tEven rows even columns\n    b.\tEven rows odd columns\n    c.\tOdd rows odd columns\n    d.\tOdd rows even columns\n\n6.\tNumber of pairs in one Train or test sets.\n\n#7.\tThe core data “Color” is of type 10\n\n8.\tThe direction of color movement \n    a.\tClockwise\n    b.\tAnti-clockwise\n    c.\tRepetition of input to output\n9.\tComplexity of colors : simple, medium & hard calculated  by (Sum) of color in set.\n![image.png](attachment:image.png)\n \n\n10.\tIf we can classify the data in above then its easy to solve the Simple & medium set.\n\n","attachments":{"image.png":{"image/png":"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"}}},{"metadata":{"trusted":true},"cell_type":"code","source":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Apr 20 18:09:37 2020\n\n@author: Sangram Phadke\n\"\"\"\nimport numpy as np\nimport pandas as pd\n\nimport os\nimport json\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\n\n# for dirname, _, filenames in os.walk('Abstraction-and-Reasoning-Challenge'):\n#     print(dirname)\n    \n\ndata_path = Path('training')\ntraining_path = data_path\n\n\ntraining_tasks = sorted(os.listdir(training_path))\n\nlist_training_tasks = []\nlist_training_tasks.append(training_tasks)\n\nalist_training_tasks =np.array(list_training_tasks).reshape(400,1)\ndf = pd.DataFrame(data = alist_training_tasks)\n\n#print(training_tasks[:3])\n\n# task_file = str(training_path / '0520fde7.json')\n# task_file = str(training_path / 'bd4472b8.json')\n#df = pd.DataFrame(,columns='') \n\nlist_training_tasks_number = []\n\n\nlist_train_pairs=[]\n\n\nrows_train_input  = []\n\n\ncolumns_train_input = []\n\n\ntask_file_name = []\n\ncolour_train_input = []\n\n\nrows_train_output  = []\n\n\ncolumns_train_output = [] \n\ncolour_train_output = []\n\nlist_test_pairs=[]\n\n\nrows_test_input = []\n\ncolumns_test_input = []\n\ncolour_test_input = [] \n\nrows_test_output = []\n\ncolumns_test_output = []\n\ncolour_test_output = [] \n\n\n\n\nfor i in [0]:\n    list_training_tasks_number.append(i)\n\n    task_file = str(training_path / training_tasks[i])\n   \n    task_file_name.append(task_file)\n\n\n    with open(task_file, 'r') as f:\n        task = json.load(f)\n\n\n    # task dictionary\n    # print(task.keys())\n    # print('\\n') \n    \n    n_train_pairs = len(task['train'])\n    list_train_pairs.append(n_train_pairs)\n    \n    n_test_pairs = len(task['test'])\n    list_test_pairs.append(n_test_pairs)\n    \n    #print(f'task contains {n_train_pairs} training pairs\\n')\n    #print(f'task contains {n_test_pairs} test pairs\\n')\n\n\n   \n    \n    for tp in range(0,n_train_pairs):\n        \n        #number of rows of each train input\n        rtp = len(task['train'][tp]['input'])\n        #print('Rows   of  train input {} of grid {} : '.format(tp,i),len(task['train'][tp]['input']))\n        rows_train_input.append(rtp)\n        \n        #number of columns of each train input\n        ctp = task['train'][tp]['input']\n        actp = np.array(ctp).shape\n        ##print('Columns of train input {} of grid {} : '.format(tp,i),(actp[1]))\n        columns_train_input.append(actp[1])\n\n        #number of color of each train input\n        cotp = task['train'][tp]['input']\n        #print('Colour of train input {} of grid {} : '.format(tp,i),task['train'][tp]['input'])\n        colour_train_input.append(cotp)\n        \n        #number of rows of each train output\n        rotp = len(task['train'][tp]['output'])\n        #print('Rows of train output {} of grid {} : '.format(tp,i),len(task['train'][tp]['output']))\n        rows_train_output.append(rotp)\n        \n        #number of columns of each train output\n        cotp = task['train'][tp]['output']\n        acotp = np.array(cotp).shape\n        #print('Columns of train output {} of grid {} :'.format(tp,i),(acotp[1]))\n        columns_train_output.append(acotp[1])\n        \n        #number of colors of each train output\n        fcolro = task['train'][tp]['output']\n        #print('Colour of train output {} of grid {} : '.format(tp,i),task['train'][tp]['output']) \n        colour_train_output.append(fcolro)\n\n    for te in range(0,n_test_pairs):\n        \n        #number of rows of each test input\n        frite = len(task['test'][te]['input'])\n        #print('Rows of train input {} of grid {} : '.format(te,i),len(task['test'][te]['input']))\n        rows_test_input.append(frite)\n        \n        #number of columns of each test input  \n        fcite = task['test'][te]['input']\n        afcite = np.array(fcite).shape\n        #print('Columns of train input {} of grid {} :'.format(te,i),afcite[1])\n        columns_test_input.append(afcite[1])\n        \n        #number of colours of each test input\n        fcolrto = task['test'][te]['input']\n        #print('Colour of train input {} of grid {} : '.format(te,i),task['test'][te]['input'])\n        colour_test_input.append(fcolrto)\n        \n        #number of rows of each test output\n        frote = len(task['test'][te]['output'])\n        #print('Rows of train output {} of grid {} : '.format(te,i),len(task['test'][te]['input']))\n        rows_test_output.append(frote)\n        \n        #number of columns of each test output\n        fcote = task['test'][te]['output']\n        afcote = np.array(fcote).shape\n        #print('Columns of train input {} of grid {} :'.format(te,i),afcote[1])\n        columns_test_output.append(afcote[1])\n        \n        #number of colours of each test output\n        fcolrtoo = task['test'][te]['output']\n        #print('Colour of train output {} of grid {} : '.format(te,i),task['test'][te]['input'])\n        colour_test_output.append(fcolrtoo)\n        \n\n\nalist_training_tasks_number = np.array(list_training_tasks_number)\ndf0 = pd.DataFrame(list_training_tasks_number,columns=['list_training_tasks_number'])\n\n\nalist_train_pairs = np.array(list_train_pairs)\ndf1 = pd.DataFrame(alist_train_pairs,columns=['list_train_pairs']) \n\narows_train_input = np.array(rows_train_input)\ndf2 = pd.DataFrame(arows_train_input,columns=['rows_train_input']) \n\nacolumns_train_input = np.array(columns_train_input)\ndf3 = pd.DataFrame(acolumns_train_input,columns=['columns_train_input']) \n\n# atask_file_name = np.array(task_file_name)\n# df4 = pd.DataFrame(task_file_name)\n\nacolour_train_input = np.array(colour_train_input)\ndf5 = pd.DataFrame(colour_train_input)\n\narows_train_output = np.array(rows_train_output)\ndf6 = pd.DataFrame(arows_train_output,columns=['rows_train_output'])\n\nacolumns_train_output = np.array(columns_train_output)\ndf7 = pd.DataFrame(acolumns_train_output,columns=['columns_train_output'])\n\nacolour_train_output = np.array(colour_train_output)\ndf8 = pd.DataFrame(colour_train_output )\n\nalist_test_pairs = np.array(list_test_pairs)\ndf9 = pd.DataFrame(alist_test_pairs ,columns=['list_test_pairs'])\n\narows_test_input = np.array(rows_test_input)\ndf10 = pd.DataFrame(arows_test_input,columns=['rows_test_input'])\n\nacolumns_test_input = np.array(columns_test_input)\ndf11 = pd.DataFrame(acolumns_test_input,columns=['columns_test_input'])\n\nacolour_test_input = np.array(colour_test_input)\ndf12 = pd.DataFrame(colour_test_input)\n\narows_test_output = np.array(rows_test_output)\ndf13 = pd.DataFrame(arows_test_output,columns=['rows_test_output'])\n\nacolumns_test_output = np.array(columns_test_output)\ndf14 = pd.DataFrame(acolumns_test_output,columns=['columns_test_output'])\n\nacolour_test_output = np.array(colour_test_output)\ndf15 = pd.DataFrame(colour_test_output)\n\ndf_all=pd.concat([df0,df1,df2,df3,df5,df6,df7,df8,df9,df10,df11,df12,df13,df14,df15],axis=1)\n\n\n#df_all.to_csv('file1.csv',index=False)\n\n#Un-comment to take print of file.\n\n\n\n# #display the task\n# def plot_task(task):\n#     \"\"\"\n#     Plots the first train and test pairs of a specified task,\n#     using same color scheme as the ARC app\n#     \"\"\"\n#     cmap = colors.ListedColormap(\n#         ['#000000', '#0074D9','#FF4136','#2ECC40','#FFDC00',\n#           '#AAAAAA', '#F012BE', '#FF851B', '#7FDBFF', '#870C25'])\n#     norm = colors.Normalize(vmin=0, vmax=9)\n#     fig, axs = plt.subplots(1, 4, figsize=(15,15))\n#     axs[0].imshow(task['train'][0]['input'], cmap=cmap, norm=norm)\n#     axs[0].axis('off')\n#     axs[0].set_title('Train Input')\n#     axs[1].imshow(task['train'][0]['output'], cmap=cmap, norm=norm)\n#     axs[1].axis('off')\n#     axs[1].set_title('Train Output')\n#     axs[2].imshow(task['test'][0]['input'], cmap=cmap, norm=norm)\n#     axs[2].axis('off')\n#     axs[2].set_title('Test Input')\n#     axs[3].imshow(task['test'][0]['output'], cmap=cmap, norm=norm)\n#     axs[3].axis('off')\n#     axs[3].set_title('Test Output')\n#     plt.tight_layout()\n#     plt.show()\n# plot_task(task)\n\n\n\n\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Import libraries and define hyperparameters"},{"metadata":{"_uuid":"8f2839f25d086af736a60e9eeb907d3b93b6e0e5","_cell_guid":"b1076dfc-b9ad-4769-8c92-a6c4dae69d19","trusted":true},"cell_type":"code","source":"import os\nimport gc\nimport cv2\nimport json\nimport time\n\nimport numpy as np\nimport pandas as pd\n\nfrom pathlib import Path\nfrom keras.utils import to_categorical\n\nimport seaborn as sns\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\n\nimport plotly.figure_factory as ff\n\nimport torch\nT = torch.Tensor\nimport torch.nn as nn\nfrom torch.optim import Adam\nfrom torch.utils.data import Dataset, DataLoader","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"TEST_PATH = Path('../input/abstraction-and-reasoning-challenge/')\nSUBMISSION_PATH = Path('../input/abstraction-and-reasoning-challenge/')\n\nTEST_PATH = TEST_PATH / 'test'\nSUBMISSION_PATH = SUBMISSION_PATH / 'sample_submission.csv'","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Load the ARC data"},{"metadata":{},"cell_type":"markdown","source":"### Get testing tasks"},{"metadata":{"trusted":true},"cell_type":"code","source":"test_task_files = sorted(os.listdir(TEST_PATH))\n\ntest_tasks = []\nfor task_file in test_task_files:\n    with open(str(TEST_PATH / task_file), 'r') as f:\n        task = json.load(f)\n        test_tasks.append(task)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"### Extract training and testing data"},{"metadata":{"trusted":true},"cell_type":"code","source":"Xs_test, Xs_train, ys_train = [], [], []\n\nfor task in test_tasks:\n    X_test, X_train, y_train = [], [], []\n\n    for pair in task[\"test\"]:\n        X_test.append(pair[\"input\"])\n\n    for pair in task[\"train\"]:\n        X_train.append(pair[\"input\"])\n        y_train.append(pair[\"output\"])\n    \n    Xs_test.append(X_test)\n    Xs_train.append(X_train)\n    ys_train.append(y_train)","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"matrices = []\nfor X_test in Xs_test:\n    for X in X_test:\n        matrices.append(X)\n        \nvalues = []\nfor matrix in matrices:\n    for row in matrix:\n        for value in row:\n            values.append(value)\n            \nTest_df = pd.DataFrame(values)\nTest_df.columns = [\"values\"]","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Basic exploration"},{"metadata":{},"cell_type":"markdown","source":"## Look at a few train/test input/output pairs\nThese are some of the pairs present in the training data. "},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"data_path = Path('/kaggle/input/abstraction-and-reasoning-challenge/')\ntraining_path = data_path / 'training'\ntraining_tasks = sorted(os.listdir(training_path))\n\nfor i in [1, 19, 8, 15, 9]:\n\n    task_file = str(training_path / training_tasks[i])\n\n    with open(task_file, 'r') as f:\n        task = json.load(f)\n\n    def plot_task(task):\n        \"\"\"\n        Plots the first train and test pairs of a specified task,\n        using same color scheme as the ARC app\n        \"\"\"\n        cmap = colors.ListedColormap(\n            ['#000000', '#0074D9','#FF4136','#2ECC40','#FFDC00',\n             '#AAAAAA', '#F012BE', '#FF851B', '#7FDBFF', '#870C25'])\n        norm = colors.Normalize(vmin=0, vmax=9)\n        fig, ax = plt.subplots(1, 4, figsize=(15,15))\n        ax[0].imshow(task['train'][0]['input'], cmap=cmap, norm=norm)\n        width = np.shape(task['train'][0]['input'])[1]\n        height = np.shape(task['train'][0]['input'])[0]\n        ax[0].set_xticks(np.arange(0,width))\n        ax[0].set_yticks(np.arange(0,height))\n        ax[0].set_xticklabels([])\n        ax[0].set_yticklabels([])\n        ax[0].tick_params(length=0)\n        ax[0].grid(True)\n        ax[0].set_title('Train Input')\n        ax[1].imshow(task['train'][0]['output'], cmap=cmap, norm=norm)\n        width = np.shape(task['train'][0]['output'])[1]\n        height = np.shape(task['train'][0]['output'])[0]\n        ax[1].set_xticks(np.arange(0,width))\n        ax[1].set_yticks(np.arange(0,height))\n        ax[1].set_xticklabels([])\n        ax[1].set_yticklabels([])\n        ax[1].tick_params(length=0)\n        ax[1].grid(True)\n        ax[1].set_title('Train Output')\n        ax[2].imshow(task['test'][0]['input'], cmap=cmap, norm=norm)\n        width = np.shape(task['test'][0]['input'])[1]\n        height = np.shape(task['test'][0]['input'])[0]\n        ax[2].set_xticks(np.arange(0,width))\n        ax[2].set_yticks(np.arange(0,height))\n        ax[2].set_xticklabels([])\n        ax[2].set_yticklabels([])\n        ax[2].tick_params(length=0)\n        ax[2].grid(True)\n        ax[2].set_title('Test Input')\n        ax[3].imshow(task['test'][0]['output'], cmap=cmap, norm=norm)\n        width = np.shape(task['test'][0]['output'])[1]\n        height = np.shape(task['test'][0]['output'])[0]\n        ax[3].set_xticks(np.arange(0,width))\n        ax[3].set_yticks(np.arange(0,height))\n        ax[3].set_xticklabels([])\n        ax[3].set_yticklabels([])\n        ax[3].tick_params(length=0)\n        ax[3].grid(True)\n        ax[3].set_title('Test Output')\n        plt.tight_layout()\n        plt.show()\n\n    plot_task(task)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Number frequency <a id=\"number-frequency\"></a>"},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"px.histogram(df, x=\"values\", title=\"Numbers present in matrices\")","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"From the above graph, we can clearly see that the number distribution has a string positive skew. Most numbers in the matrices are clearly 0. This is reflected by the dominance of black color in most matrices."},{"metadata":{},"cell_type":"markdown","source":"## Matrix mean values <a id=\"matrix-mean-values\"></a>"},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"means = [np.mean(X) for X in matrices]\nfig = ff.create_distplot([means], group_labels=[\"Means\"], colors=[\"green\"])\nfig.update_layout(title_text=\"Distribution of matrix mean values\")","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"From the above graph, we can see that lower means are more common than higher means. The graph, once again, has a strong positive skew. This is further proof that black is the most dominant color in the matrices."},{"metadata":{},"cell_type":"markdown","source":"## Matrix heights <a id=\"matrix-heights\"></a>"},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"heights = [np.shape(matrix)[0] for matrix in matrices]\nwidths = [np.shape(matrix)[1] for matrix in matrices]","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"fig = ff.create_distplot([heights], group_labels=[\"Height\"], colors=[\"magenta\"])\nfig.update_layout(title_text=\"Distribution of matrix heights\")","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"From the above graph, we can see that matrix heights have a much more uniform distribution (with significantly less skew). The distribution is somewhat normal with a mean of approximately 15."},{"metadata":{},"cell_type":"markdown","source":"## Matrix widths <a id=\"matrix-widths\"></a>"},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"fig = ff.create_distplot([widths], group_labels=[\"Width\"], colors=[\"red\"])\nfig.update_layout(title_text=\"Distribution of matrix widths\")","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"From the above graph, we can see that matrix widths also have a uniform distribution (with significantly less skew). The distribution is also somewhat uniform with a mean of approximately 16."},{"metadata":{},"cell_type":"markdown","source":"## Height vs. Width <a id=\"height-vs-width\"></a>"},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"plot = sns.jointplot(widths, heights, kind=\"kde\", color=\"blueviolet\")\nplot.set_axis_labels(\"Width\", \"Height\", fontsize=14)\nplt.show(plot)","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":true,"trusted":true},"cell_type":"code","source":"plot = sns.jointplot(widths, heights, kind=\"reg\", color=\"blueviolet\")\nplot.set_axis_labels(\"Width\", \"Height\", fontsize=14)\nplt.show(plot)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"From the above graphs, we can see that heights and widths have a strong positive correlation, *i.e.* greater widths generally result in greater heights. This is consistent with the fact that most matrices are square-shaped."},{"metadata":{},"cell_type":"markdown","source":"### Define function to flatten submission matrices"},{"metadata":{"trusted":true},"cell_type":"code","source":"#Submission \n\ndef flattener(pred):\n    str_pred = str([row for row in pred])\n    str_pred = str_pred.replace(', ', '')\n    str_pred = str_pred.replace('[[', '|')\n    str_pred = str_pred.replace('][', '|')\n    str_pred = str_pred.replace(']]', '|')\n    return str_pred","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"### Prepare submission dataframe"},{"metadata":{"trusted":true},"cell_type":"code","source":"test_predictions = [[list(pred) for pred in test_pred] for test_pred in test_predictions]\n\nfor idx, pred in enumerate(test_predictions):\n    test_predictions[idx] = flattener(pred)\n    \nsubmission = pd.read_csv(SUBMISSION_PATH)\nsubmission[\"output\"] = test_predictions","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"### Convert submission to .csv format"},{"metadata":{"trusted":true},"cell_type":"code","source":"submission.head()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"submission.to_csv(\"submission.csv\", index=False)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Ending note:\n\nFrom the other Notebooks Copyed the code to read the data in my note book. rest of the core code & analysis is my own (Feel free to do same with this note book if you find valuable)\n\nImp Note: Big thanks to  Walter & Tarun Paparaju many more..\n\nPease upvote if like it."}],"metadata":{"kernelspec":{"language":"python","display_name":"Python 3","name":"python3"},"language_info":{"pygments_lexer":"ipython3","nbconvert_exporter":"python","version":"3.6.4","file_extension":".py","codemirror_mode":{"name":"ipython","version":3},"name":"python","mimetype":"text/x-python"}},"nbformat":4,"nbformat_minor":4}